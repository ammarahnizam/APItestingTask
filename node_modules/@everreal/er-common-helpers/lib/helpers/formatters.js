"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var currencyFormatter = require("currency-formatter");
var moment = require("moment-timezone");
var numeral = require("numeral");
require("moment/locale/de");
var validation_1 = require("./validation");
var momentLocaleMap = {
    'en-US': 'en',
    'de-DE': 'de',
};
exports.DATE_FORMATS = {
    SHORT_DATE: 'L',
    LONG_DATE: 'LL',
    FULL_DATE_TIME_SHORT: 'LLL',
    GENERAL_DATE_TIME_SHORT: 'L LT',
    DATE: 'LL',
    DAY_DATE: 'dddd, LL',
    DATE_TIME: 'LL, LT',
    DATE_TIME_24_FORMAT: 'LL, HH:mm',
    DAY_MONTH_HMS: 'DD. MMMM, LTS',
    DAY_MON_YEAR: 'DD. MMM YYYY',
    DD_MM_YYYY: 'DD.MM.YYYY',
    DD_MM_YY: 'DD.MM.YY',
    HH_mm: 'HH:mm',
    IS_24: 'YYYY-MM-DD',
    CALENDAR_ICS: 'YYYY-MM-DD HH:mm:ss',
};
function getDate(date) {
    if (Object.prototype.toString.call(date) === '[object Date]') {
        return date;
    }
    return new Date(date);
}
function formatDate(_a) {
    var date = _a.date, _b = _a.locale, locale = _b === void 0 ? 'de-DE' : _b, _c = _a.format, format = _c === void 0 ? exports.DATE_FORMATS.DAY_DATE : _c, _d = _a.offset, offset = _d === void 0 ? 0 : _d, _e = _a.tz, tz = _e === void 0 ? '' : _e;
    var momentLocale = momentLocaleMap[locale];
    moment.locale(momentLocale);
    var dt = getDate(date);
    var momentDate = moment(dt);
    if (offset) {
        return momentDate.utcOffset(offset).format(format);
    }
    if (tz) {
        return momentDate.tz(tz).format(format);
    }
    return momentDate.format(format);
}
exports.formatDate = formatDate;
function formatDateFromNow(_a) {
    var date = _a.date, _b = _a.locale, locale = _b === void 0 ? 'de-DE' : _b;
    var momentLocale = momentLocaleMap[locale];
    moment.locale(momentLocale);
    var dt = getDate(date);
    var momentDate = moment(dt);
    return momentDate.fromNow();
}
exports.formatDateFromNow = formatDateFromNow;
function formatCurrency(amount, symbol) {
    if (symbol === void 0) { symbol = 'EUR'; }
    var opt = {
        code: symbol,
    };
    if (symbol === 'EUR') {
        opt.decimal = ',';
        opt.thousand = '.';
    }
    return currencyFormatter.format(amount, opt);
}
exports.formatCurrency = formatCurrency;
function findCurrencySymbol(code) {
    if (code === void 0) { code = 'EUR'; }
    return currencyFormatter.findCurrency(code).symbol;
}
exports.findCurrencySymbol = findCurrencySymbol;
if (!numeral.locales.de) {
    numeral.register('locale', 'de', {
        delimiters: {
            thousands: '.',
            decimal: ',',
        },
        abbreviations: {},
        ordinal: function () { return ({}); },
        currency: {},
    });
}
function formatDouble(value, options, locale) {
    if (locale === void 0) { locale = 'de'; }
    if (validation_1.isEmpty(value) || isNaN(value)) {
        return null;
    }
    numeral.locale(locale);
    if (Number.isInteger(value)) {
        return numeral(value).format('0,0');
    }
    var maxDecimalsAfterComma = options && options.maxDecimalsAfterComma;
    var exactDecimalsAfterComma = options && options.exactDecimalsAfterComma;
    var decimalsAfterCommaInValue = ("" + value).split('.')[1].length;
    var numberOfDecimalsAfterComma = maxDecimalsAfterComma && maxDecimalsAfterComma < decimalsAfterCommaInValue
        ? maxDecimalsAfterComma
        : decimalsAfterCommaInValue;
    var finalNumberOfDecimalsAfterComma = exactDecimalsAfterComma || numberOfDecimalsAfterComma;
    var decimals = '0'.repeat(finalNumberOfDecimalsAfterComma);
    return numeral(value).format("0,0." + decimals);
}
exports.formatDouble = formatDouble;
//# sourceMappingURL=formatters.js.map