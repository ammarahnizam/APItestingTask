"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_mock_1 = require("../__mocks__/errors.mock");
var __1 = require("../");
var errorMappers_1 = require("./../errorMappers");
describe('WHEN testing errors', function () {
    describe('WHEN testing swagger schema validation error', function () {
        it('SHOULD be swagger error', function () { return expect(errorMappers_1.isSwaggerValidationError(errors_mock_1.swaggerSchemaValidationFailedError)).toBe(true); });
        it('SHOULD have correct format', function () {
            var result = errorMappers_1.formatSwaggerValidationError(errors_mock_1.swaggerSchemaValidationFailedError);
            expect(result).toEqual({
                isValidationError: true,
                type: 'ValidationError',
                error: 'Expected type string but found type object',
                locale: 'any.api.validation.INVALID_TYPE.contractDetails.petsAllowed',
            });
        });
    });
    describe('WHEN testing swagger required error', function () {
        it('SHOULD be swagger error', function () { return expect(errorMappers_1.isSwaggerValidationError(errors_mock_1.swaggerRequiredError)).toBe(true); });
        it('SHOULD be formatted correctly', function () {
            var result = errorMappers_1.formatSwaggerValidationError(errors_mock_1.swaggerRequiredError);
            expect(result).toEqual({
                isValidationError: true,
                type: 'ValidationError',
                error: "The parameter '" + errors_mock_1.swaggerRequiredError.paramName + "' is required.",
                locale: "any.api.validation.REQUIRED." + errors_mock_1.swaggerRequiredError.paramName,
            });
        });
    });
    describe('WHEN testing swagger schema validation error missing required property', function () {
        it('SHOULD be swagger error', function () { return expect(errorMappers_1.isSwaggerValidationError(errors_mock_1.swaggerMissingRequiredPropertyError)).toBe(true); });
        it('SHOULD be formatted correctly', function () {
            var result = errorMappers_1.formatSwaggerValidationError(errors_mock_1.swaggerMissingRequiredPropertyError);
            expect(result).toEqual({
                isValidationError: true,
                type: 'ValidationError',
                error: "Missing required property: period",
                locale: "any.api.validation.OBJECT_MISSING_REQUIRED_PROPERTY.contractDetails.period",
            });
        });
    });
    describe('WHEN testing sequelize error', function () {
        it('SHOULD be sequelize error', function () { return expect(errorMappers_1.isSequelizeError(errors_mock_1.sequelizeError)).toBe(true); });
        it('SHOULD have correct format', function () {
            var result = errorMappers_1.formatSequelizeError(errors_mock_1.sequelizeError);
            expect(result).toEqual({
                errors: [
                    {
                        message: 'listing_created_by_company_id must be unique',
                        path: 'listing_created_by_company_id',
                        type: 'unique violation',
                    },
                    {
                        message: 'title must be unique',
                        path: 'title',
                        type: 'unique violation',
                    },
                ],
                locale: 'validation.listing_created_by_company_id.must.be.unique',
                name: 'SequelizeUniqueConstraintError',
                type: 'DataValidationError',
            });
        });
    });
    describe('WHEN error is ValidationError', function () {
        it('SHOULD be known error', function () { return expect(errorMappers_1.isKnownError(new __1.ValidationError('Description', 'locale'))).toBe(true); });
    });
    describe('WHEN error is ValidationErrorWithStatus', function () {
        it('SHOULD be known error', function () {
            return expect(errorMappers_1.isKnownError(new __1.ValidationErrorWithStatus(404, 'Description', 'locale'))).toBe(true);
        });
    });
    describe('WHEN error is ValidationErrorSilent', function () {
        it('SHOULD be known error', function () { return expect(errorMappers_1.isKnownError(new __1.ValidationErrorSilent('Description', 'locale'))).toBe(true); });
    });
    describe('WHEN error is CriticalError', function () {
        it('SHOULD be known error', function () { return expect(errorMappers_1.isKnownError(new __1.CriticalError('Description', 'locale'))).toBe(true); });
        it('SHOULD be critical error', function () { return expect(errorMappers_1.isCriticalError(new __1.CriticalError('Description', 'locale'))).toBe(true); });
    });
});
//# sourceMappingURL=errors.test.js.map